<meta http-equiv="content-type" content="text/html; charset=utf-8" /><style>	canvas {		background: #f8f8f8;		border: 1px solid gray;	}	#tooltip {		position: absolute;		border: 1px solid gray;		padding-left: 10px;		padding-right: 10px;		display: none;		font-size: 20px;	}</style>Java：<input name="courses" item="Java" value="220" /><br/>C：<input name="courses" item="C" value="120" /><br/>PHP：<input name="courses" item="PHP" value="100" /><br/>Android：<input name="courses" item="Android" value="190" /><br/>iOS：<input name="courses" item="iOS" value="160" /><br/>Web：<input name="courses" item="Web" value="60" /><br/><button onclick="genPiechart();">生成图表</button><br/><canvas id="c" width="450px" height="450"></canvas><div id="tooltip"></div><script>	let c = document.querySelector("#c");	let ctx = c.getContext("2d");	// 输入数据	let courses;	// 设置文字绘制都以x，y坐标位置居中对齐	ctx.textAlign = "center";	ctx.textBaseline = "middle";	const FONT_SIZE = 20;	ctx.font = `${FONT_SIZE}px Times New Roman`;	const WIDTH = c.width;	const HEIGHT = c.height;	const X = WIDTH / 2;	const Y = HEIGHT / 2;	const R = 180;	const COLORS = ["rgba(255, 0, 0, 0.3)", "rgba(0, 255, 0, 0.3)", "rgba(0, 0, 255, 0.3)", "rgba(89, 100, 200, 0.3)", "rgba(200, 200, 200, 0.3)", "rgba(155, 10, 90, 0.3)"];	let gen = false;		// 文字显示区域的中心点（存储起来为了后面判断鼠标靠近哪一个）	let positions = [];	// 鼠标移动事件	c.onmousemove = e => {		if (gen) {			let x = e.offsetX;			let y = e.offsetY;			let position = getPosition(x, y);			with(document.querySelector("#tooltip")) {				if (position == -1) {					style.display = "none";					c.style.cursor = "default";				}				else {					style.display = "block";					textContent = courses[position].value;					style.top = e.clientY + 10;					style.left = e.clientX + 10;					c.style.cursor = "pointer";				}			}		}	}	// 根据鼠标位置判断靠近哪一个文字区域	let getPosition = (x, y) => {		let pos = -1;		positions.forEach(({halfX, halfY}, index) => {			// 文件的宽度			let textWidth = ctx.measureText(courses[index].getAttribute("item")).width;			if (x > halfX - textWidth / 2 - 10 && x < halfX + textWidth / 2 + 10 && y > halfY - FONT_SIZE / 2 - 10 && y < halfY + FONT_SIZE / 2 + 10)				pos = index;		});		return pos;	}		// 某个扇形区的百分比	let getPercent = (value) => {		let sum = 0;		courses.forEach(course => {			sum += parseInt(course.value);		});		return value / sum;	}		let genPiechart = () => {		gen = true;		courses = document.querySelectorAll("input[name='courses']");				ctx.clearRect(0, 0, WIDTH, HEIGHT);		let startRadian = Math.PI * 3 /2;		let endRadian = 0;		// 绘制扇形		courses.forEach((course, index) => {			// 当前扇形的百分比弧度			let curRadian = getPercent(course.value) * Math.PI *2;			// 当前扇形的结束弧度			let endRadian = startRadian + curRadian;			ctx.beginPath();			ctx.moveTo(X, Y);			ctx.arc(X, Y, R, startRadian, endRadian);			ctx.fillStyle = COLORS[index];			ctx.fill();			// 下一个扇形的起始弧度等于上一个扇形的结束弧度			startRadian = endRadian;					});		ctx.fillStyle = "#FFFFFF";		startRadian = Math.PI * 3 /2;		endRadian = 0;		positions = [];		// 绘制文字		courses.forEach((course, index) => {			// 当前扇形的百分比弧度			let curRadian = getPercent(course.value) * Math.PI *2;			// 当前扇形的结束弧度			let endRadian = startRadian + curRadian;			// 当前扇形的中分线弧度			let halfRadian = (startRadian + endRadian) / 2;			// 中分线的中间点位置						// 文字区域的中心点（绘制坐标）			let halfX = X + R * Math.cos(halfRadian) / 2;			let halfY = Y + R * Math.sin(halfRadian) / 2;			ctx.fillText(course.getAttribute("item"), halfX, halfY);			positions.push({halfX, halfY});						// 下一个扇形的起始弧度等于上一个扇形的结束弧度			startRadian = endRadian;					});		console.log(courses);	}		</script>